# Chapter 1
- HTTP, HTML의 관계
  - HTTP프로토콜을 사용하여 HTML(Hyper text markup language)를 전송한다.
  - HTML은 자료구조로 Tree를 사용한다.
  - 프로토콜 : 신탁스(Syntax), 시맨틱(semantics), 엑션(action)

# Chapter 2
## 2.8. Special Characters and More Line Breaks
- Special Characters(특수문자)
  - 코드는 단축된 이름 또는 16진수
  - `&amp;` = &
  - `&copy;` = @
- Line Breaks
  - del : 텍스트를 삭제됨으로 지정(취소선)
  - sup : 텍스트를 위 첨자로 지정
  - sub : 텍스트를 아래 첨자로 지정
  - hr : 수평으로 선을 긋는 엘리먼트
  - strong : 텍스트 강조
## 2.9. Unordered List
- 순서가 없는 리스트
  - ul : 정리되지 않는 목록 생성
  - li : 각 목록 항목을 정리
## 2.10. Nested and Ordered List
- Nested List
  - 리스트 안의 리스트
~~~~
<ul>
	<li>
        <ul>
        </ul>
    </li>
</ul>
~~~~

- Ordered List
  - 순서가 있는 리스트
~~~~
<ol>
    <li> </li>
    <li> </li>
</ol>
~~~~

# Chapter 3
## 3.4. Basic HTML Forms
- 클라이언트로부터 입력을 얻는다.
- form
  - form을 시작
  - method : 요청 타입
  - action : 처리 스크립트 위치.
- input
  - 양식 요소를 지정(서버로 데이터를 넘겨줄 때, 데이터의 형식을 알려주는 것)
  - type : 양식 요소의 유형
  - value : 양식 요소의 값
  - name : 양식 요소에 이름을 지정

## 3.5. More Complex HTML Forms
- textarea
  - 텍스트 상자 생성
  - rows : 행의 수 지정
  - cols : 열의 수 지정
- password
  - 글씨가 안보이는 textarea
- checkbox
  - 여러개 선택 가능한 체크박스 생성
  - 같은 이름의 체크박스가 그룹화 된다
- radio
  - 라디오 버튼 생성(여러가지 중 하나만 선택 가능)
  - 같은 이름의 라디오 버튼이 그룹화 된댜
- select
  - 드롭다운 선택박스 생성
  - size : 보이는 옵션 수 지정
  - option : 드롭 상자 옵션 생성
  - type = hidden : 상수 선언하는 것과 비슷
~~~~
   <p>
      <input type = "hidden" name = "recipient"
         value = "deitel@deitel.com">
      <input type = "hidden" name = "subject" 
         value = "Feedback Form">
      <input type = "hidden" name = "redirect" 
         value = "main.html"> 
   </p>
~~~~

## 3.6. Internal Linking
- 페이지 안에서 이루어짐
- 한 페이지 안에서 앵커를 정의
- 앵커에게 하이퍼링크를 적용
~~~~
<p><a href = "#ceos">Go to <em>Favorite CEOs</em></a></p>

                    |          하이퍼 링크를 사용하면 브라우저가 
                    V          ceos anchor로 직접 이동

<p><a name = "ceos"></a></p>
~~~~

## 3.7. Creating and using Image Maps
- hotspot : 그림의 일부분(구역)
- 이미지의 hotspot을 정의하는 방법
- map : 이미지 맵의 요소들을 포함
  - name : 임의의 이름을 정의
- area : hotspot을 정의
  - href : 하이퍼링크 url
  - shape : 구역의 모양 지정
  - coords : 핫스팟의 위치 지정(x,y 위치로 나타냄)

## 3.8. meta tags
- 실제 사용되는 정보는 아니지만 특정 데이터를 사용할 때 보조를 해줄 수 있는 것
- name
  - 메타 태그 유혛
  - keyword : 검색 엔진에 검색 가능한 키워드를 제공
  - description : 검색 엔진 사용자에게 설명 제공
- content
  - 메타 태그에 대한 정보.

# Chapter 4
## 4.1. Introduction
- Cascading Style Sheet
  - 문서의 스타일을 정의하는 것
  - 보여주는 방법을 다양하게 할 수 있다.
## 4.2. Inline Style
- Style
  - 문서 안에서 스타일을 정의
  - 스타일 충돌 시 Inline Style이 우선됨(override된다.)
~~~~
<p style = "font-size: 20pt"; color: #00ff00> asdf </p>
~~~~
## 4.3. Creating Styles with the style element
- head 안에 포함되어 있음
- 문서 전체에 적용이 가능하다.
~~~~
<style type = "text/css">
    em {background-color : #8000ff;
        color : white}
    h1 {font-family : A, B} // 폰트를 A로 하되 없으면 B로 하라.
    p  {font-size : 14pt}
    .special {color : blue} // 스타일 클래스 지정
</style>
~~~~
## 4.4. Conflicting Styles
- 스타일을 작성한 사람, 혹은 스타일의 적용되는 element의 범위에 따라 충돌 발생 가능
- 인라인 스타일은 다른 모든 스타일보다 우선한다.
- 스타일의 우선순위
  - Author(제작자) > User > Agent(웹 브라우저)
> - a.nodec -> 데코레이션 없음 (no decoration)  
> - a:hover -> 앵커 엘리먼트에 적용. 마우스를 가져다 대면 수행됨.  
> - li em -> list 안의 em태그

## 4.5. Linking External Style Sheet
- .css 파일 안에 포함되어 있다.
- 한개의 css 파일이 여러개의 페이지에 사용 가능
- link element 사용
~~~~
<link rel = "stylesheet" type = "text/css" href = "styles.css>
~~~~

## 4.6. Positioning Elements
- position 프로퍼티
  - Absolute 포지셔닝
    - element의 위치를 픽셀로 정의
    - 브라우저로 위치가 정해지지 않는다.
  - Relative
    - 상대적인 위치

## 4.10. User Style Sheets
- User-defined stlyes
  - 유저가 스타일 커스터마이즈 가능

# Chapter 5
## 5.1. Introduction
- XML
  - 확장 가능한 마크업 언어
    - 불필요한 태그 삭제, 혹은 새로운 태그 추가 가능
  - 문서 작성자가 모든 유형의 데이터를 설명 할 수 있도록한다.
  - 새로운 태그를 만드는 것을 허용
    - HTML은 고정된(정해진) 태그만 사용 가능
    - XML과 HTML은 서로 다른 목표를 가지고 디자인 되어 있다.
    > - XML은 데이터 전송을 위한 디자인 - 데이터 내용에 집중
    > - HTML은 데이터 디스플레이를 위한 디자인 - 데이터가 어떻게 보이는지
    - XML 태그는 자유롭게 정의 가능
## 5.2. Introduction to XML Markup
- XML documet
  - text파일로 저장되며, 확장자는 .xml
- tree 구조로 저장
~~~~
<myMessage>                                   myMessage는
  <message> Welcome to XML! </message>        message를 포함한다.
</myMessage>
~~~~
- 반드시 하나의 root 엘리먼트를 가져야 된다.
  - 하나 이상의 root 엘리먼트 생성 시 에러 발생 
- 반드시 nest 포함관계가 유지되어야 한다.
~~~~
<x><y> asdf </x></y>     ->     x
<x><y> asdf </y></x>     ->     o
~~~~
## 5.3. Parsers and Well-formed XML Documents
- XML parser
  - xml 문서를 읽은 후 syntax 체크를 하는 것
    1. xml 문서를 읽고
    2. 문법 확인 후
    3. 에러가 있을시 리포트
    4. xml의 문서에 접근 가능 (DOM, SAX)
        - Document Object Model
          - 문서의 데이터를 트리 구조로 메모리에 저장
        - Simple API for XML
          - 모든 자료를 한 줄씩 읽어서 그때 그때 처리(interpreter) 
          - DOM과 달리 creative / delete가 안된다.
          - 대신 수행속도가 빠르다.(메모리 이용x) -> 임베디드에 사용
- XML document syntax
  - 하나의 루트 엘리먼트
  - 모든 엘리먼트는 시작, 끝 태그를 가져야 된다.
  - 태그는 포함관계가 유지되어야 된다.
  - 속성은 ""로 묶어준다.
  - 대소문자 구분 함 

## 5.6. MarkUp
- XML element markup 
  - 시작 태그, 콘텐츠, 끝 태그로 구성됨
  - 모든 엘리먼트들은 반드시 끝 태그가 있어야됨
~~~~
<img src = "image.gif"></img>
or 
<img src = "image.gif"/>
~~~~
- element
  - 구조를 정의
  - 자식 엘리먼트, 캐릭터 데이터 등 content를 포함 or 안포함
- Attributes
  - element 묘사
  - element 시작 태그에 위치
  - "" 사이에 값이 들어감
- PI
  - xml 정보를 어플리케이션에게 제공
  - `<?  ?>` 안에 들어감
~~~~
<?xml:stylesheet type = "text/xsl" href = "usage.xsl"?>
~~~~

## 5.7. CDATA Sections
- Character Data -> 읽는 글자 그대로 포함
- XML 파서가 무시한다
- 스크립팅 코드(자바 등)에서 많이 쓰인다.
~~~~
<![CDATA[           
if(this->getX() < 5 && value[0] != 3)
  cerr << this->displayError();
]]>
~~~~

## 5.8. XML Namespace
 - 마이크로 소프트에서 쓰는 개념.
 - 태그 이름이 똑같을 수도 있는데 이것을 구분해주는 것을 말한다.
 - xmlns : namespace 생성

# Chapter 6
## 6.1. Introduction
- DTD
  - xml 문서의 구조를 정의한다.
  - 무조건 필요로 하지 않는다
  - EBNF 문법을 사용한다.
## 6.2. Parsers, Well-formed and Valid XML Documents
- Parsers
  - 유효할 시
    - DTD를 읽어온다.
    - XML 문서가 DTD를 따르는지 여부를 결정한다.
    - 유효한 문서는 DTD를 따른다. 
  - 유효하지 않을 시
    - DTD를 읽어온다
    - 문서를 DTD와 맞는지 확인하지 않는다.

## 6.3. ~ 6.8. 문법 정리
- Document Type
- Element Type
  - , : and
  - | : or
  - +: 한번 이상 포함해야된다
  - *: 안올수도 있고 여러번 올 수도 있다.
  - ?: 없거나 한번만 오거나. 
  - EMPTY : 아무 element를 포함하지 않는다.
  - MIXED : 문자데이터(#PCDATA)나 자식 요소를 같이 같는다.
  - ANY : 모든 유형의 데이터 포함
- Attribute Declaration
  - ATTLIST
    - element에 대한 추가적인 정보를 제공하며, 해당 요소의 특징을 정의
  - #IMPLIED : 사용되지 않을 경우 default값으로 사용
  - #REQUIRE : 반드시 사용되어야 함
  - #FIXED   : 고정값. FIXED로 정의된 값이 element 값으로 사용되어야 한다.
- Attribute Type
  - ID	이 타입의 속성값은 하나뿐인 아이디(id)임.
  - IDREF	이 타입의 속성값은 다른 요소의 아이디(id)임
  - ENTITY	이 타입의 속성값은 엔티티(entity)임.
  - NMTOKEN	이 타입의 속성값은 유효한(valid) XML 이름임.


# Chapter 7
## 7.2. Schema vs DTDs
- DTDs
  - 유연하지 않다. 
  - 확장자 DTD
  - 데이터 타입을 지원하는 기능이 부족
  - 엘리먼트, 속성 등의 지원 기능이 미흡
  - 데이터 정렬이 어려움
  - EBNF 문법 

- Schema
  - 유연하다
  - 확장자 XSD
  - 풍부한 데이터 타입 지원
  - 엘리먼트, 속성 기능 지원 좋음
  - 데이터 정렬 가능
  - XML 문법

# Chapter 8
- DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
  - 돔파서를 사용하기 위해 메소드를 불러오기
  - 돔파서를 사용하기 위해 객체에서 새로운 인스턴스 생성
  - true : DTD와 비교, false : DTD와 비교해서 달라도 에러 안남.
- DocumentBuilder builder = factory.newDocumentBuilder();
  - Parser를 사용한 XML을 불러오거나 만들기 위한 Builder를 생성
- parse : 분석 (new File("intro.xml")) -> intro.xml을 읽고 파싱한다.
- Node root = document.getDocumentElement();
  - root => rect 노드 가져오기
- write : 새로운 xml 문서 생성
- 순서
  1. 돔파서를 사용하기 위해 메소드 불러오기
  2. DTD와 비교하며 문서 검사
  3. builder를 선언하여 돔파서를 생성
# Chapter 9
- DOM 과 SAX의 XML Parsing 방법
  - DOM : 트리 형태로 메모리에 유지, 저장되어 있다.
    - 컴파일러와 비슷, 웹페이지를 저장하고 키워드를 찾거나 수정
    -  XML 문서전체를 읽어 트리구조 객체를 생성 후 이용. 트리구조이기 때문에 노드관리가 쉽다.
    > 문서를 여러번 읽거나 수정해야 할 때 DOM 사용
    - 메모리에 항상 존재해 data 접근이 빠르다.(추가, 삭제, update 등 수행)
  - SAX : 메모리에 놓이지 않음 -> 검색만 가능하다(추가, 삭제 불가능)-> 차례로 읽어가면서 element, Attribute가 인식될 때마다 Event 발생 후 바로 처리
    - 루틴을 계속해서 수행 해 줘야 한다.
    > DOM은 한번만 하면 저장되어서 반복하지 않아도 됨 -> 다시 시작할 때마다 처음부터 다시 읽음
    - 트리형태 유지 X
    - 태그를 만나면 element 시작과 끝만 안다.
    - 전달 대상이 명확할 때 SAX 써도 무관하다. 읽을 때만 메모리 사용한다. 메모리 관점에서 성능은 DOM보다 좋다 (임베디드에서 유용) 
    - xml문서를 읽어 들일 때, 메모리 속도가 우선일 경우 SAX 이용